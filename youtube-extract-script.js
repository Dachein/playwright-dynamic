/**
 * ğŸ¬ YouTube ä¸“ç”¨æå–è„šæœ¬
 * 
 * ç›´æ¥åœ¨æµè§ˆå™¨ä¸­è°ƒç”¨ Innertube APIï¼Œè¾“å‡ºæ ‡å‡†çš„ metadata + markdown æ ¼å¼
 * 
 * è¾“å‡ºç»“æ„ï¼š
 * {
 *   metadata: { title, author, publisher, publishDate, thumbnail, description },
 *   markdown: "ç»„è£…å¥½çš„ Markdown å†…å®¹",
 *   extra: { videoId, duration, hasTranscript, transcriptLang, isAutoGenerated }
 * }
 */

const YOUTUBE_EXTRACT_SCRIPT = `
(async function() {
  const INNERTUBE_KEY = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8';
  
  try {
    // 1ï¸âƒ£ ä»é¡µé¢è·å– videoId
    const pr = window.ytInitialPlayerResponse;
    const videoId = pr?.videoDetails?.videoId || new URLSearchParams(location.search).get('v');
    if (!videoId) return { error: 'No video ID found' };
    
    // 2ï¸âƒ£ è°ƒç”¨ Innertube API è·å–å®Œæ•´æ•°æ®
    const res = await fetch('https://www.youtube.com/youtubei/v1/player?key=' + INNERTUBE_KEY, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        videoId,
        context: {
          client: { clientName: 'WEB', clientVersion: '2.20231219.04.00', hl: 'en', gl: 'US' }
        }
      })
    });
    const data = await res.json();
    
    if (data.playabilityStatus?.status !== 'OK') {
      return { error: data.playabilityStatus?.reason || 'Video unavailable' };
    }
    
    const vd = data.videoDetails || {};
    const mf = data.microformat?.playerMicroformatRenderer || {};
    
    // 3ï¸âƒ£ æå–æ ‡å‡† metadataï¼ˆ6 ä¸ªå­—æ®µï¼‰
    const metadata = {
      title: vd.title || '',
      author: vd.author || '',
      publisher: vd.author || '',  // YouTube çš„ publisher å°±æ˜¯ author
      publishDate: mf.publishDate || mf.uploadDate || '',
      thumbnail: 'https://img.youtube.com/vi/' + videoId + '/maxresdefault.jpg',
      description: (vd.shortDescription || '').substring(0, 500)
    };
    
    // 4ï¸âƒ£ æå–å­—å¹•
    let transcript = '';
    let transcriptLang = null;
    let isAutoGenerated = false;
    
    const captions = data.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    if (captions && captions.length > 0) {
      // ä¼˜å…ˆé€‰æ‹©ï¼šæ‰‹åŠ¨å­—å¹• > ASRï¼Œè‹±æ–‡ > ä¸­æ–‡ > å…¶ä»–
      const langPriority = ['en', 'zh', 'zh-Hans', 'zh-Hant'];
      const manualTracks = captions.filter(t => t.kind !== 'asr');
      const asrTracks = captions.filter(t => t.kind === 'asr');
      const tracksToSearch = manualTracks.length > 0 ? manualTracks : asrTracks;
      
      let selectedTrack = null;
      for (const lang of langPriority) {
        selectedTrack = tracksToSearch.find(t => t.languageCode?.startsWith(lang));
        if (selectedTrack) break;
      }
      if (!selectedTrack) selectedTrack = tracksToSearch[0];
      
      if (selectedTrack) {
        transcriptLang = selectedTrack.languageCode;
        isAutoGenerated = selectedTrack.kind === 'asr';
        
        // è·å–å­—å¹•å†…å®¹
        const transcriptRes = await fetch(selectedTrack.baseUrl + '&fmt=json3');
        const transcriptData = await transcriptRes.json();
        
        for (const event of (transcriptData.events || [])) {
          for (const seg of (event.segs || [])) {
            if (seg.utf8) transcript += seg.utf8;
          }
        }
        transcript = transcript.replace(/\\n/g, ' ').trim();
      }
    }
    
    // 5ï¸âƒ£ æå–ç« èŠ‚ï¼ˆä»æè¿°ä¸­è§£æï¼‰
    const chapters = [];
    const desc = vd.shortDescription || '';
    const chapterRegex = /\\(??(\\d+:)?(\\d+:\\d+)\\)??\\s*[-â€“]?\\s*(.+)/gm;
    let match;
    while ((match = chapterRegex.exec(desc)) !== null) {
      const timeMatch = match[0].match(/\\d+:\\d+:\\d+|\\d+:\\d+/);
      if (timeMatch) {
        const time = timeMatch[0];
        const title = match[0].replace(timeMatch[0], '').replace(/^[\\s\\-â€“()]+/, '').trim();
        if (time && title && title.length < 100) {
          chapters.push({ time, title });
        }
      }
    }
    
    // 6ï¸âƒ£ æ ¼å¼åŒ–æ—¶é•¿
    let duration = '';
    const secs = parseInt(vd.lengthSeconds || '0', 10);
    if (secs > 0) {
      const h = Math.floor(secs / 3600);
      const m = Math.floor((secs % 3600) / 60);
      const s = secs % 60;
      duration = h > 0 
        ? h + ':' + String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0')
        : m + ':' + String(s).padStart(2, '0');
    }
    
    // 7ï¸âƒ£ ç»„è£… Markdown
    let markdown = '## Original Metadata:\\n\\n';
    markdown += '**Title:** ' + metadata.title + '\\n\\n';
    
    const metaLines = [];
    if (metadata.author) metaLines.push('**Channel:** ' + metadata.author);
    if (metadata.publishDate) metaLines.push('**Date:** ' + metadata.publishDate);
    if (duration) metaLines.push('**Duration:** ' + duration);
    metaLines.push('**Source:** ' + location.href);
    markdown += metaLines.join(' | ') + '\\n\\n';
    
    // è¿‡æ»¤æ‰ç« èŠ‚æ—¶é—´æˆ³çš„æè¿°
    if (metadata.description) {
      const coreDesc = metadata.description
        .split('\\n')
        .filter(line => !line.match(/^\\(?\\d+:\\d+/))
        .join('\\n')
        .trim();
      if (coreDesc) {
        markdown += '**Original_introduction:**\\n\\n' + coreDesc + '\\n\\n';
      }
    }
    
    markdown += '---\\n\\n';
    
    // ç« èŠ‚
    if (chapters.length > 0) {
      markdown += '## Chapters\\n\\n';
      for (const ch of chapters) {
        markdown += '- (' + ch.time + ') ' + ch.title + '\\n';
      }
      markdown += '\\n';
    }
    
    // å­—å¹•
    if (transcript) {
      const type = isAutoGenerated ? 'Auto-generated' : 'Manual';
      markdown += '## Transcript (' + type + ', ' + transcriptLang + ')\\n\\n';
      markdown += transcript + '\\n';
    } else {
      markdown += '## Transcript\\n\\n*No transcript available*\\n';
    }
    
    // 8ï¸âƒ£ è¿”å›æ ‡å‡†æ ¼å¼
    return {
      metadata,
      markdown,
      extra: {
        videoId,
        duration,
        chapters,
        hasTranscript: transcript.length > 0,
        transcriptLang,
        isAutoGenerated,
        transcriptLength: transcript.length
      }
    };
    
  } catch (e) {
    return { error: e.message, stack: e.stack };
  }
})()
`;

module.exports = { YOUTUBE_EXTRACT_SCRIPT };
